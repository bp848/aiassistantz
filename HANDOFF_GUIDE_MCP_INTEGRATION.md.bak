# MCP統合ハンドオフガイド：クラウド社長室Z

## 🎯 このアプリケーションの設計思想

「受動的なチャットボットから、能動的なエグゼクティブ・ファンクション（実行機能）へ」

- **コンテキストの連続性**: 社長の仕事はチャット画面で完結しません。メール、カレンダー、Driveの資料はすべて繋がっています。MCP接続の目的は、これらバラバラなデータを「社長の文脈」として一本の線に繋げることです。
- **承認ベースの自動化**: AIが勝手にメールを送ることは許されません。しかし、AIが「完璧な返信案」を裏で作っておき、社長が1タップで送信できる状態を作るのが、最高峰の秘書の仕事です。
- **ゼロ・サーチの実現**: 社長が「あの資料どこだっけ？」と探す時間をゼロにします。会話の流れから、MCP経由で必要なファイルを先回りしてワークスペース（サイドパネル）に展開します。

## 🏗️ アプリケーション構造

### ファイル構成
```
aiassistantz/
├── src/
│   ├── App.tsx                 # メインアプリケーション
│   ├── components/
│   │   ├── ChatMessage.tsx     # チャットメッセージ表示
│   │   ├── ChatInput.tsx        # 入力欄
│   │   └── WorkspacePanel.tsx   # サイドパネル
│   ├── services/
│   │   ├── geminiService.ts     # AIロジック（要MCP接続）
│   │   └── mcpService.ts        # MCP通信レイヤー（新規作成）
│   ├── types/
│   │   └── index.ts            # 型定義
│   └── utils/
│       └── constants.ts        # 定数
├── .env.local                   # APIキー（絶対に公開しない）
└── package.json
```

### 現在の問題点
- `geminiService.ts` 内のツール呼び出しがすべて**モックデータ**になっている
- `liveCalendar`, `searchGmail`, `createDraft` などの関数がダミーデータを返している
- UIは完成しているが、データソースが実物に接続されていない

## 🔧 MCP接続後の具体的なユースケース

### ユースケース①：超高精度「朝のブリーフィング」
**動作**: 社長が「おはよう」と言った瞬間、MCPがカレンダーの全予定と、過去24時間の重要未読メールをスキャンします。

**秘書の振る舞い**:
「おはようございます。本日は14時から文唱堂印刷との商談ですが、先ほど先方の橋本社長から『30分遅らせてほしい』とのメールが届いています。後ろの予定を調整し、承諾の返信案を作成しておきました。承認いただけますか？」

**価値**: スケジュール管理とコミュニケーションの完全同期。

### ユースケース②：過去の文脈を反映した「代理執筆」
**動作**: 社長が「〇〇社に、例のプロジェクトの進捗確認メールを書いて」と指示。

**秘書の振る舞い**:
MCPで過去のメールスレッドと、Drive内のプロジェクト計画書を検索。過去の社長の口調（「〜ですな」「承知いたしました」等）を学習した上で、最新の進捗数値を反映したドラフトを作成します。

**価値**: 「ゼロからの執筆」を無くし、社長の思考コストを大幅に削減。

### ユースケース③：会議中の「即時エビデンス提示」
**動作**: 会議モード中、社長が「去年の利益率の推移はどうだったかな」と独り言のように質問。

**秘書の振る舞い**:
MCP経由で会計報告書（PDF/Excel）の中身を検索・抽出し、サイドパネルのワークスペースにグラフや表として即座に表示します。

**価値**: 議論を止めない情報の即時供給。

### ユースケース④：カレンダーとタスクの「矛盾検知」
**動作**: カレンダーに「A社訪問（移動1時間）」が入っているが、その直前の会議が延びそうな場合。

**秘書の振る舞い**:
「社長、次の移動を考えると今の会議をあと10分で切り上げる必要があります。先方に『少し遅れる可能性がある』と一報入れておきましょうか？」

**価値**: 物理的な制約（移動時間等）まで考慮した、人間以上の管理。

## 🛠️ 実装ロードマップ

### Phase 1: MCPブリッジの構築
**作業内容**: `services/mcpService.ts` の作成
- MCPサーバーとのSSE/WebSocket接続を確立
- `listTools()` と `callTool()` メソッドを実装
- エラーハンドリングと再接続ロジック

**完成の定義**: MCPサーバーからツール一覧が取得できること

### Phase 2: 既存モック関数の実接続化
**作業内容**: `geminiService.ts` の書き換え
- `handleToolCall` 関数をMCP呼び出しに置き換え
- 各ツール関数（`liveCalendar`, `searchGmail` 等）をMCP経由に

**完成の定義**: カレンダーやメールの参照時に、実際のデータがコンソールに流れること

### Phase 3: レスポンス・アダプターの作成
**作業内容**: MCPデータのUI整形
- MCPの生JSONを既存UIタグ（`:::email`, `:::draft` 等）に変換
- データ構造のマッピングと正規化

**完成の定義**: MCPデータが既存UIで正しく表示されること

### Phase 4: 能動的コンテキスト注入
**作業内容**: 自動的な文脈構築
- 会話開始時の自動スキャン機能
- 動的システムプロンプトの更新

**完成の定義**: AIが能動的に情報を収集・提示するようになること

### Phase 5: UIの「警告」解除
**作業内容**: 実稼働状態への移行
- 「シミュレーション中」表示の削除
- 本物のAPIキー使用への切り替え

**完成の定義**: アプリが完全に実機能として動作すること

## 🔐 セキュリティ要件

### APIキー管理
- **絶対にコード内にハードコードしない**
- `process.env.GOOGLE_API_KEY` を使用
- `.env.local` ファイルは `.gitignore` に含める

### 権限設計
- **Read-Only First**: 参照（List/Get）は自由、書き込み（Send/Create）はユーザー承認必須
- **プライバシーフィルタ**: カレンダーの「タイトル」のみ参照、「詳細」は明示的リクエスト時のみ
- **トークン節約**: MCPサーバー側での事前要約を実装

### ガードレール
```
ユーザー入力 → AI判断 → MCP実行 → UI表示
     ↑           ↓         ↓
   承認ボタン ← 書き込み操作 ← 確認ダイアログ
```

## 🎨 UIプロトコルの維持

### 既存の表示タグ（変更禁止）
- `:::email {JSON} :::` - メール表示
- `:::draft {JSON} :::` - 下書き表示
- `:::schedule {JSON} :::` - スケジュール表示
- `:::ticket {JSON} :::` - チケット表示

### データ形式の例
```javascript
// メール表示の場合
:::email {
  "subject": "件名",
  "from": "送信者",
  "preview": "本文プレビュー...",
  "timestamp": "2024-01-31T10:00:00Z",
  "important": true
} :::

// スケジュール表示の場合
:::schedule {
  "title": "A社商談",
  "time": "14:00-15:00",
  "location": "会議室A",
  "attendees": ["田中", "鈴木"]
} :::
```

## 📋 関数一覧とMCP対応

### 置換が必要な関数（geminiService.ts内）
| 現在の関数 | MCPツール名 | 説明 |
|-----------|------------|------|
| `liveCalendar` | `list_events` | 今日の予定取得 |
| `searchGmail` | `search_threads` | Gmail検索 |
| `getGmailMessage` | `get_message` | メール詳細取得 |
| `createDraft` | `create_draft` | 下書き作成 |
| `sendMessage` | `send_message` | メール送信 |
| `createEvent` | `create_event` | カレンダー作成 |
| `updateEvent` | `update_event` | カレンダー更新 |

### 新規作成が必要な関数
| 関数名 | 説明 |
|--------|------|
| `mcpConnect` | MCPサーバー接続 |
| `listMcpTools` | 利用可能ツール一覧取得 |
| `executeMcpTool` | MCPツール実行 |
| `formatResponse` | MCP→UIデータ変換 |

## 🚀 最初の一手：別AIへの指示

これをコピペして別のAIに渡してください：

---
「クラウド社長室ZのMCP統合を開始します。まず、このHANDOFF_GUIDE_MCP_INTEGRATION.mdを熟読してください。

最初のタスク:
実際のMCPサーバーと通信するための services/mcpService.ts を作成してください。その後、services/geminiService.ts 内の handleToolCall を、現在のダミーデータ返却から、MCP経由での実ツール実行へと切り替えてください。

注意点:
- 既存の :::email や :::draft といったUI表示プロトコルは維持したまま、背後のデータソースだけを本物に差し替えることがミッションです
- APIキーは process.env.GOOGLE_API_KEY を使用してください
- セキュリティガードレールを必ず実装してください
- Phase 1 → Phase 5 の順に確実に進めてください」

---

## 📞 連絡先とサポート

このドキュメントの内容で不明な点がある場合は、プロジェクトのオリジナル設計者に確認してください。

**重要**: このアプリは単なるツール接続ではありません。社長の「脳の拡張」として機能することが最終目標です。常にユーザー体験を第一に考えて実装を進めてください。

---

*最終更新: 2025年1月31日*
*バージョン: 1.0.0*
